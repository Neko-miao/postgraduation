# 基于动画共享和LOD实现高效实时的大规模群体动画渲染  
## 摘要  
## Abstract  
## 图目录  
## 表目录  
## 第1章 绪论  
### 1.1 研究背景和意义  
- 大规模群体动画渲染的发展现状和应用领域；  
    大规模群体动画是图形学领域中的热门研究课题，它通过模拟和控制大规模群体中个体的行为，实现自然、逼真和适应性的动画效果，从鱼群、鸟群到人群、交通流等各种群体行为都可以通过大规模群体动画进行模拟和展示。随着计算机性能的提升和算法技术的不断进步，大规模群体动画的研究得到了飞跃的发展，大规模群体动画的实时性和真实感有了显著的提高。研究者们通过引入群体行为模型、仿真算法和先进的渲染技术（附加具体模型、算法或技术），不仅能够模拟复杂的群体行为，还能呈现出逼真的视觉效果。大规模群体动画的发展不仅推动了动画产业的发展，也为交通规划、生态环境模拟等领域提供了重要的参考和工具。在游戏领域，大规模群体动画往往能带来震撼的视觉效果，游戏开发者通过大规模群体动画可以创建更加生动的游戏场景和NPC角色，提升游戏的沉浸感和真实感。此外，利用大规模群体动画技术可以模拟呈现大规模战争、人群等场景，不仅减少了开发成本，为制作团提供更多的创作自由度，还为用户带来了更加真实和沉浸式的体验。  
- 说明大规模群体动画的关键问题；  
    大规模群体动画是图形学中具有挑战性的研究课题之一，其关键技术难点主要包括群体行为建模、群体智能和渲染技术等方面（应用引文）。群体行为建模需要设计合理的模型来描述个体之间的相互作用和群体整体的行为规律。群体智能需要通过算法和模拟方法实现个体之间的自适应和智能行为。渲染技术则需要解决大规模场景中的实时渲染和灯光效果等挑战。这些技术挑战需要研究者们通过创新和交叉学科合作来解决，从而推动大规模群体动画的进一步发展。
- 阐述当前实现大规模群体动画渲染的技术方案和对应的缺陷；
    - 说明研究重点和面临的问题
    本文研究的群体动画针对于骨骼动画，当前最通用的骨骼动画实现机制是在CPU端通过动画状态机的方式实现对动画的采样和混合，然后在CPU或GPU端对动画状态机输出的动画姿势进行蒙皮操作，最终将动画对象呈现在渲染画面中。这种机制实现的动画系统不仅可以非常精细的实现角色的动画，而且动画系统对动画状态分层以及动画叠加功能的支持，更是极大丰富了角色动画的多样性。但随着角色规模的扩大，该动画系统会面临以下问题。首先CPU端需要消耗大部分的性能来计算角色的动画姿势，其次，庞大角色的动画渲染也将面临巨大的压力。因此，本研究内容着重于改善大规模群体骨骼动画的性能并尽可能保留群体动画的多样性，最终在此基础上构建一套能够投入使用的大规模群体动画系统框架。
    - 说明加速大规模群体动画的一些解决方案  
    实现大规模群体动画的实时渲染是一项复杂的任务，需要在限定时间内渲染和处理大量的角色和动画数据，以下是一些常用的技术和方法来实现大规模群体动画的渲染。第一，LoD(Level of Detail)是其中最高效也是最常见的方法。所谓基于LoD的渲染就是根据某种条件为待渲染的模型选择合适复杂度和精度的几何表示，在渲染大量角色动画的场景中，可以根据每个角色实例对最终图像的影响力为该角色实例选择最合适的模型网格，评价图像影响力的因素有很多，最常用的就是根据渲染对象与场景摄像机之间距离。简单说，LoD技术之所以能够加速渲染，是因为它可以减少大量顶点和三角形的渲染工作，以最小的渲染质量损失换取了最大的渲染效率提升。第二，无损渲染加速技术，包括剔除技术、实例化技术和伪实例化技术等等，这些技术相对LoD技术来说不会对渲染图像造成视觉损失。剔除是渲染阶段常用的技术手段，其作用就是丢弃那些不会被看到的模型对象的全部或者部分，常见的剔除方式有视锥体剔除、遮挡剔除等。实例化技术是一种在计算机图形学中常用的优化技术，通过将相同的模型实例化多次来进行批量渲染。即通过使用相同的渲染数据，但在不同的位置和姿态上实例化多个对象，而不是渲染每个对象的独立模型。这种技术利用了GPU并行处理的特点，可以大大减少渲染调用次数和数据传输的开销，提高渲染性能。伪实例化技术是一种类似实例化技术的优化技术，在某些情况下可以替代实例化技术来降低资源和渲染开销。它通过将多个对象的渲染数据合并成一个大的渲染数据块，并在渲染过程中通过索引和偏移量来实现对对象的渲染。
    - 阐述上述方案存在的缺陷  
    尽管以上所述的技术可以加速群体动画渲染，但也存在一定程度上的缺陷。首先，目前大多数应用都选择了离散型LoD方法，即在离线时生成多份模型网格不同简化程度的版本，并在实际渲染时应用一个适合的简化版本。这种离散型LoD方法确实可以简单高效地加快渲染进程，但是多份简化的模型网格必然会增加内存占用，而且由于不同简化程度的模型网格之间很难做平滑过渡，在大规模群体动画上应用离散型LoD会使得最终地渲染效果呈现出一种“弹出式”的视觉伪像，在相机由远及近（或由近及远）地快速运动时更为明显。其次，实例化技术在渲染静态物体方面有很好的效果，但在动画渲染方面有一些短板和局限。例如因为实例化的对象共享着相同的数据模型，因此很难单独对每个实例对象实现动画的混合和控制，这很有可能导致动画之间的过渡效果不连贯以及动画多样性的丢失。
- 基于以上问题初步提出本文系统架构并说明其中的意义；  
    基于以上问题，本文提出了一套基于连续LoD的GPU动画渲染框架，该框架整合了视锥体剔除、动态网格的连续LoD选择、以及基于实例化技术的骨骼动画蒙皮和渲染，该框架充分利用了GPU强大的计算能力，高效利用GPU内存，可以高质量实现了海量动画角色的实时渲染。在CPU端，本文为海量角色的骨骼动画提出了一种基于动画状态共享的实现方案，既最大限度利用了现有的骨骼动画技术，保留了动画群体与群体模拟端（例如，群体中每个个体的决策系统、群体的寻路系统等）以及与用户端的复杂交互逻辑，又能减轻CPU端的计算压力，让CPU留有余力去处理应用中的其他模块或系统。
- 结合项目实践，再次说明本文的研究意义；  
    最终，本文结合了上述两种方案并应用于浙江无端科技股份有限公司正在研发的第一人称射击（first=person shooting，FPS）网络游戏《生死狙击2》的PVE（Player vs. Enviroment）模块中，大幅度提升了游戏中海量怪物的动画性能，提高了游戏在大规模群体场景中的交互性，增加了游戏的真实感和沉浸感。
### 1.2 国内外研究现状  
针对本文的研究内容，研究现状分为基于LoD的网格简化技术和基于GPU的实时大规模群体动画实现两个方面介绍。
#### 1.2.1 基于LoD的网格简化技术  
- 讲述LoD的意义
    大规模场景的渲染需要考虑到性能和效果之间的平衡，并且随着视点的变化而对细节级别进行适应性调整。在这方面，基于LoD的网格简化技术成为了一种非常有效的方法。大规模群体动画场景中，不同角色或对象的重要性和视点距离可能不同。基于LoD的渲染可以根据相对重要性和视点距离在不同的细节级别上渲染动画角色。对于处于远处的角色，可以选择较低的细节级别进行渲染，从而节省计算资源。而对于处于近处或重要的角色，可以选择较高的细节级别以获得更高质量的渲染效果。通过这种适应性调整细节级别，可以在满足渲染效果要求的同时提高渲染性能。尽管基于LoD来简化模型网格的研究已经相当成熟(举例一些成熟的算法和应用)，但现存工作中却很少提及如何通过LoD技术来简化动画角色的蒙皮网格。以下将会综述一些可以用于动画渲染加速的基于LoD的网格简化技术。

- 基于LoD的网格简化技术应用  
    2009年，Landreneau等人提出了一种针对骨骼动画角色多边形网格简化算法，该算法基于最小二次误差度量的思想，综合考虑了角色蒙皮顶点的权重以及角色绑定姿势和动画姿势的偏差，最终使简化后的角色模型网格更接近原始形状。他们的方法相对传统LoD技术来说，能够很好地做到动态地简化动画角色的模型网格，但是这种方法需要付出高成本的计算代价，很难满足实时应用需求。

    2010年，Feng等人引入了一种三角化的几何图像方法来保留动画角色的静态和动态特征，他们的方法可以较好的保真性在GPU端表示不同分辨率下的蒙皮动态网格，实验表明，这种方法能够实时渲染海量角色的三角形网格。但是，随着他们所提出的三角化几何图像变大，该方法就会存在潜在的LoD适应问题，即对于不同视点，最终会选择的角色网格LoD可能并不是最合适的。

    2011年，Willmott基于顶点聚类的想法，提出了一种快速简化动画角色网格的算法。尽管作者提到这种算法有可能完全在GPU上实现，但是他的算法与[progressive mesh 引用](一种基于边坍缩的网格简化算法)相比，不能够很好地产出一个能够较好保留角色外观特征的简化网格。同年，Peng等人基于[progressive mesh 引用]提出了一个在GPU端实现的人群渲染系统，这套系统不仅可以渲染不同简化程度的人物角色，而且可以很好地保留这些角色的外观纹理特性。Peng等人引用了连续LoD技术，可以在运行时简化或精细化待渲染的网格。但是，这种方法仅适合渲染拥有单一模型的人群，难以适用于拥有多种模型的人群渲染。

    2016年，Peng等人改进了边坍缩的网格简化算法，综合考虑了视觉参数以及GPU内存对复杂几何模型的内存适应性，提出了一种并行LoD方法。该研究的最大亮点在于，严格禁止了对三角形网格的边界边进行坍缩操作，保证模型网格简化后的视觉质量；利用帧到帧的连续性，最小化CPU向GPU传输的数据量；根据可使用的GPU内存大小，为模型子网格选择了最合适的LoD等级，从而最大化利用GPU的内存。Peng等人提出的方案完全在GPU上得到实现，并通过实验证明了他们的方法可以非常高的交互性帧率渲染由超过3亿三角形组成的模型网格。但是，这种方法仅适合于渲染静态的模型网格，不能直接适用于大规模的动画群体的渲染。

    除了传统意义的基于LoD的网格简化技术，深度神经网络的发展也能极大地优化LoD技术。2021年，Takikawa等人提出了一种隐式表面的神经几何表示方法，通过神经符号距离函数（Signed Distance Functions, SDFs），可以实时渲染出高保真的几何模型。论文作者用稀疏体素八叉树（Sparse Voxel Octree，SVO）来编码SDFs，并用八叉树存储深度特征，这些八叉树在不同LoD等级会有不同的版本。在渲染时，首先查询最贴近给定LoD的八叉树，然后通过三线性插值的方式获取特征值，再将特征值输入到优化后的MLP（Multi-Layer Perception）神经网络中，最终预测出符号距离。与其他表示几何模型形状的SDFs相比，该方法在渲染效率方面高出了2-3个数量级，且用插值的方式支持模型的连续LoD。


#### 1.2.2 基于GPU的实时大规模群体动画实现  
- 总结大规模群体动画实现的基本框架  
    性能和规模是群体动画实时渲染需要首先考虑的两个因素，因此几乎所有大规模群体动画渲染框架都将主要的工作放在GPU中进行，并整合了各种渲染优化技术以提升群体动画的渲染速度，同时利用实例化技术提升CPU向GPU传输数据的效率。而针对群体中角色个体动画的处理，根据具体需求与使用场景的不同，各类群体动画实现研究的侧重点也有所不同。如果完全将角色动画放在CPU中处理，这样做的优点是可以对动画做更精细的控制，保证了动画的灵活性和可扩展性，而缺点是大批量的动画计算可能造成CPU性能过载以及骨骼动画本身存在数据依赖不利于设计并发处理。如果完全将角色动画放在GPU中处理，这样做的好处是极大提升了动画计算速度，而坏处是难以保证动画的灵活性和复杂性。因此如何平衡CPU和GPU的工作是实现大规模群体动画的一个关键问题，也是本文研究的重点之一。除此之外，如何用少量的资源尽可能提供更多样更真实地动画群体，也是大规模群体动画渲染研究的一个重要问题。下文将对当前群体动画的实现技术进行了综述。  

- 综述各种大规模群体动画实现论文  
    2005年，Rudomín等人在的论文中提出了一种在GPU中实现的适用于群体智能体的动画状态机技术，其中智能体的动画是在片段着色器中生成的。这种技术不仅可以高效实现智能体的动画模拟，同时还可以减少传统动画技术中计算和存储的开销。该算法的核心思想是为智能体提供了3种可供GPU快速查询的纹理映射图，其一是世界空间纹理映射图，其二是智能体空间纹理映射图，其三是有限状态机（Finite-state machine，FSM）纹理映射图。世界空间纹理就是传统意义的纹理贴图，它为场景的每一个位置（或每一个像素）分配了一个代表某种特征的值，例如，高度贴图、法线贴图、碰撞贴图等等。智能体空间纹理为每一个智能体分配了一个像素值，该像素值可以代表智能体的状态、类型、速度以及它在世界空间纹理中的位置坐标等等。FSM纹理是一张表，表的纵轴代表智能体的所有状态，表的横轴代表某种输入，这种输入对应者世界空间纹理中个某个纹素，而表中每一个元素代表智能体在该种状态和该种输入时，应该输出的新状态值。在运行时，利用GPU快速查询这3张纹理映射图，就可以模拟智能体的状态转换，从而实现智能体对应状态下的动画。借助GPU强大的运算能力，这种方式可以快速渲染出大量支持动画的角色模型，而且通过扩展3种纹理映射图可以实现智能体更为复杂的行为逻辑。但是这种方式是相对简单场景而言的，而且很难支持智能体与智能体之间或智能体与其他系统之间的交互功能。

    2008年，Park等人提出了一种快速渲染大规模人群动画的技术，该技术同样利用GPU强大的图形处理能力，提升了渲染效率和渲染质量。该论文提出的方案核心要点是尽可能让将更少的渲染工作留给CPU，而让GPU承担更多的工作。其算法分为三个阶段进行，第一阶段利用AABB盒（Axis-aligned bounding box）包围待渲染的角色，并假定角色的位置就是AABB包围盒的中心，在渲染管线中，角色网格模型的顶点将首先经过顶点着色器变换到裁剪空间，此时利用AABB包围盒可以较方便地将位于裁剪空间之外角色网格模型剔除掉，减轻后续渲染的工作量的同时，还可以快速计算出角色模型在裁剪空间中的深度信息，然后在之后的几何着色器中，角色模型网格的LoD会由它在裁剪空间的深度决定，在Park等人的实现中所采用的是离散LoD模型。由第一阶段产生的所有模型网格的离散LoD信息会被存储在同一个缓存中，因此算法进入第二阶段时，首先对第一阶段产生各种LoD下的模型网格进行排序并分类存储，即相同等级LoD的网格会被放在同一个缓存中，这样做的目的是为了组织GPU友好的数据结构，为后续模型网格的渲染提供并行处理的便利。最后，算法进入第三阶段，利用DirectX提供的实例化技术为每一个角色网格模型实例做动画蒙皮并渲染出来，该技术要求每次处理模型的分辨率是一致的，这也是第二阶段会对第一阶段的LoD缓存做排序和分类处理的原因。这项技术的确可以快速渲染大规模人群的动画，但仅适用于单一角色模型的人群，且离散LoD的使用仍然无法避免“弹出式”视觉伪像的缺陷。

    2017年，Paduraru提出了一种高效实现人群动画模拟的框架，该框架在不预存任何动画信息的前提下提高了人群动画的多样性和可用性，框架使用了一种高效实现CPU和GPU之间动画数据流动的方法，最后还提出一个新的技术用于实现人群中单个人物模型的动画融合。在Paduraru的实现中，动画数据被定义为动画流，动画流包含动画的骨骼结构、蒙皮顶点、蒙皮顶点权重、动画的当前输出姿势、用于更新动画状态的动画控制器以及动画姿势缓存历史，该动画流由CPU驱动更新，通过动画控制器计算得到当前人物模型姿势并缓存下来，供其他播放相同动画的不同模型共享。模型的动画流信息会被存储在一张图片结构上，图片的每一行存储了该动画流所包含的单个动画的某一帧所有骨骼的空间信息，即各个骨骼的局部空间坐标，不同的动画流会被存储在不同的图片上，最后打包所有的动画流数据并实时同步到GPU中，而GPU会用相似的结构在存储这些动画流数据。在该框架中，角色动画的融合仍然在CPU端进行，与传统动画融合方案不同的地方在于，系统会把融合后的动画也姿势存储下来，融合后的动画数据也会同步给GPU。最后，系统在GPU端利用实例化技术，根据所有角色的动画流信息计算角色模型的蒙皮顶点坐标和蒙皮顶点的光照，最终将模型渲染出来。Paduraru的方案提出了一种动画姿势共享的机制，该机制在保留角色动画原本的多样性的同时有效地减少了CPU处理动画数据的性能开销，而且最终的动画数据既可以较好的组织成利于CPU与GPU之间传输的数据结构，又方便GPU进行并行操作。但是这种框架可能得到许多拥有相同姿势的动画角色，会给动画人群最终的渲染效果造成潜在的视觉伪像影响，框架中使用的动画流结构不仅保存了大量动画融化的数据，而且在GPU中也缓存了相同信息的副本，造成了内存空间的浪费。

    2018年，Sung提出一种基于GPU的可以快速渲染超过1000个角色的群体动画渲染技术，其群体中的每个角色的移动动画都是由动作捕捉技术来驱动的。Sung的方案核心点在于分离CPU和GPU的工作，并将静态数据（如模型的绑定姿势数据等）和动态数据（如模型骨骼的实时坐标数据等）分离。CPU的主要工作是分解动作捕捉数据并据此以前向运动学的方式计算角色骨骼的局部坐标矩阵，同时更新角色的全局坐标信息，接着将所有角色的骨骼变换矩阵及其全局位置和朝向打包成单个一维数组结构，通过SSBO（Shader Storage Buffer Object）方式发送给GPU。在GPU中就可以利用实例化技术，快速定位到每个角色的骨骼变换矩阵和全局坐标位置，然后经过渲染管线将角色的骨骼展示在屏幕上。Sung通过SSBO的方式提高了CPU与GPU之间的通信效率，实力化技术的应用可以保证正确地渲染人群中的每一个角色，但是由Sung的数据组织方式可知，他的实现方案要求所有角色的骨骼数量是一致的，这也导致该方案不能直接适用于拥有多种骨骼架构的人群动画渲染。最后需要指出的是，Sung没有对角色进行蒙皮，而是利用Phone光照模型为角色的骨骼着色，这意味着他不需要考虑众多蒙皮顶点给渲染带来的潜在压力。

    2019年，Dong等人提出了一种实现大规模动画人群高效渲染的方案，该方案整合了LoD技术和可见性剔除技术，可以在GPU端有效管理多种角色类型的数据。Dong等人的方案把渲染人群动画的工作基本交给GPU执行，CPU主要负责角色数据预处理以及人群动画模拟（如群体寻路模拟等）。CPU的预处理工作包括各种角色模型网格简化预处理以及将角色的骨架结构、蒙皮权重、蒙皮顶点法线、角色动画等信息烘培到不同的纹理图片中，在运行时，CPU会向GPU传输所有角色实例的全局信息。在GPU中，Dong等人构建了一条运行时管线，经过该管线的角色势力会最终渲染在屏幕上。管线首先进入视锥体剔除阶段，此阶段会根据模型的包围球信息剔除掉摄像机视野以外的模型；然后进入到LoD选择阶段，此阶段会依据每个角色实例对渲染图像的最终贡献值来决定角色网格实例将会有多少顶点被渲染；接着进入到网格重构阶段，该阶段根据上一个阶段选出的需要渲染的顶点集并结合角色网格简化的预处理数据，重新生成角色的三角形蒙皮网格结构，并为每个顶点设置正确的UV坐标；接着进入到动画生成阶段，该阶段会根据预先烘培好的动画纹理和蒙皮权重纹理等信息以及角色实例数据为角色生成最终的动画蒙皮网格；最终进入渲染阶段将角色渲染在画面之中。Dong等人的方案有效利用了连续LoD技术，相对传统的离散LoD来说，既节约了内存和性能开销，又提高了人群渲染的视觉质量，而且，他们的方案支持多种不同类型的角色，能直接增加人群动画的多样性。当然，这个方案也存在一些不足的地方，首先，人群中的角色个体只有单个动画，不能满足复杂多样及过渡平滑的动画需求，其次，这个方案采用的连续LoD技术是基于静态网格实现的，对于动态的蒙皮网格可能造成潜在的视觉伪像。

    2022年，Paduraru等人对他们之前的框架进行扩展和改进，提出一个新的大规模人群动画模拟框架，与以前的框架相比，新框架不仅进一步提升了大规模人群的渲染效率以及内存利用率，而且明显提升了大规模人群动画的多样性，满足性能要求的同时还能提升群体动画的视觉质量。Paduraru等人的新框架首先扩展了动画流的定义，新增了动画流状体参数，只有当该状态激活的时候该动画流的动画控制器才会真正执行。其次，新框架分解了角色骨架及其对应的动画，这样做的好处是既避免了单一骨架结结构可能造成的存储浪费，又为动画的共享提供了便利。再次，新框架提出了一种时间扩张机制，这种机制会给共享中的动画或者过渡动画增加一个动态的偏差值，有效避免了前文中提到的因动画共享带来的潜在视觉伪像的影响。最后，新框架将动画流数据完全存储在GPU中，但数据仍然由CPU来驱动更新，同时框架提出了一种在GPU实现的动画过渡方案，不同于传统骨骼动画过渡方式，即先对角色骨骼进行插值操作再根据最终骨骼姿势为角色蒙皮，该动画过渡方案直接在顶点着色器中根据当前过渡时间对角色动画过渡对应的源动画蒙皮顶点和目标动画蒙皮顶点进行线性插值，这样做减少了动画过渡姿势的内存占用，提高了计算效率。Paduraru等人为了进一步提升人群动画的多样式和真实感，还提出了一种程序驱动的自定义角色动画的方式，即先对需要进行自定义动画的角色蒙皮顶点进行标记，然后编写自定义动画驱动程序，最后在角色完成蒙皮操作之后对标记的蒙皮顶点运行自定义动画程序，当然，这种做法适合实现一些简单的动画效果，例如通过设计角色头部蒙皮顶点的旋转实现视觉跟随（LookAt）效果。Paduraru等人的方案在一款足球游戏中得到应用，即模拟足球场的观众席人群，受限于产品需求，这种方案最合适的应用场景也是正是这种作为背景的角色人群，因此难以满足动画人群与场景或游戏玩家的复杂交互需求，且背景角色模型相对简单，Paduraru等人的工作没有进一步实现人群角色的渲染优化。  

    
### 1.3 研究内容和主要工作  
#### 1.3.1 研究内容  
#### 1.3.2 主要工作  
- 贡献：
    - 改进网格简化算法，能够适应蒙皮网格，能够支持多种模型的的连续LOD  
    - 一套通用的基于GPU的动画渲染框架  
    - 动画共享机制，并在unity中以插件的方式实现  
### 1.4 本文组织架构  
### 1.5 本章小结  
## 第2章 关键技术综述  
### 2.1 CPU加速动画处理方案  
本文研究的重点是基于骨骼动画的大规模群体动画渲染系统，因此，本小节将介绍骨骼动画的基础知识，包括骨骼动画的实现原理以及在CPU快速实现大规模人群动画骨骼计算的方案。
#### 2.1.1 骨骼动画原理
骨骼动画是一种常用的角色动画技术，广泛应用于电影、游戏等领域。它通过操作骨骼系统来控制角色的运动和变形。骨骼动画的原理在于基于骨骼结构的层次模型，通过对骨骼关节进行操作来驱动角色的动作。骨骼是角色动画中的基本组成部分，它定义了角色的形状和运动。一个骨骼通常由一个或多个关节组成，并通过层次结构进行组织。关节是连接骨骼的节点，可以旋转和变形。对于人形角色而言，我们通常用BVH（BioVision Hierarchy）结构来描述它的骨骼结构，如下图所示。  
[图2.1 人形骨骼示例]  
在骨骼动画中，所有骨骼关节的一组旋转和形变集合称为一个姿势。在定义姿势时，常见的方法是将每个关节的坐标空间相对于其父关节的坐标空间进行表示。通过建立骨骼层次结构，每个骨骼根据其父关节的坐标空间来进行相对旋转或形变。这样的设定可以保持骨骼之间的连贯性，使得角色的运动看起来更加流畅自然。而所谓骨骼动画可以被定义为一系列关键帧，每个关键帧表示了在不同时间点上的骨骼姿势。动画师或设计师根据需要在关键时刻设置关键帧，然后通过插值等技术来生成中间帧，以形成流畅的动画过渡。

现假设有一个骨骼层次结构，其中每个骨骼都有一个局部变换矩阵 $M^{local}$ 和一个全局变换矩阵 $M^{global}$。局部变换矩阵表示一个骨骼相对其父骨骼空间的变换，全局变换矩阵表示了一个骨骼相对于整个骨架模型空间的变换。对于根骨骼而言，其全局变换矩阵就是其局部变换矩阵，表示如下为  $M_{root}^{global} = M_{root}^{local}$，而对于某个非根骨骼$j$，假设其父骨骼为$parent_j$，则该骨骼的全局变换矩阵表示为$M_{j}^{global} = M_{parent_j}^{global} * M_{j}^{local}$，据此，就可以计算出所有骨骼的全局变换矩阵。  
在运行时为角色播放动画时，首先从动画中采样出各个骨骼的局部空间坐标，然后根据以上公式就可以计算出所有骨骼的模型空间坐标或全局空间坐标。

除了骨骼之外，我们还需要为动画角色定义一个皮肤模型，该模型网格的每个顶点都会与一组骨骼或关节进行绑定，以便在动画过程中根据骨骼的变化来实时更新模型的形状，这个过程就是蒙皮（Skinning）。在说明蒙皮之间，我们还需要介绍绑定姿势（Bind Pose）的概念，绑定姿势定义为骨骼动画的初始状态，它确定了模型和骨骼之间的初始关系，包括顶点与骨骼的权重分配和关联，即绑定姿势为蒙皮提供了一个基准，蒙皮也需要据此计算顶点的位置和旋转。  

现假设$v$表示绑定姿势下模型的某个顶点坐标，$n$表示所有能够影响该顶点坐标的骨骼数量（一般来说$n \leq 4$），$M_i$表示其中第$i$个骨骼的当前全局变换矩阵，其影响权重为$w_i$，$M_{bind_i}$表示第$i$个骨骼在绑定姿势下的全局变换矩阵，则当前该顶点的实际坐标表示为：  
$$ v' = \sum_i^n w_i M_i M_{bind_i}^{-1} v , \space where \space \sum_i^n w_i = 1$$  

#### 2.1.2 基于动画流的骨骼动画实现  
- 介绍动画流，包括功能、工作流、优势等
Paduraru等人在论文中提出了一种基于动画流的动画框架，该动画框架支持不同类型的角色骨架、支持共享动画的差异化、支持GPU端的动画过渡、支持不同骨骼动画的组合等等。以下部分将具体介绍动画流框架的工作原理。
- 给出动画流的定义以及动画控制器的作用  
- 动画分割
- 时间膨胀实现的动画差异化（可选）
- CPU与GPU之间的数据流  
- GPU实现的动画过渡  
### 2.2 大规模人群实时渲染技术  
目前实现大规模人群实时渲染的方法几乎都是在GPU上实现的，其中用得最多的技术主要有：基于LoD的三角形简化、基于图像的渲染技术、实例化或伪实例化技术等等。本小节将详细介绍连续LoD技术以及动画实例化技术。
#### 2.2.1 连续LOD技术  
- 简要介绍各种LoD技术并引出基于边坍缩的方法实现连续LoD  
    LoD技术大致可以分为离散型LoD和连续型LoD，前文提到，离散型LoD技术虽然简单易用，但是会给最终渲染出的大规模人群造成一种“弹出式”的视觉伪像。本文主要研究连续型LoD技术，而连续LoD的实现依赖于各种网格简化算法，目前对网格简化算法的研究可以归为5类，分别是：基于顶点抽取、基于顶点聚类、基于区域合并、基于细分网格以及基于迭代边坍缩，而本文研究的重点是基于迭代边坍缩的网格简化算法，以下内容将分为3小节来分别介绍经典的QSlim网格简化算法、在GPU可并行的网格简化方法以及连续LoD选择。  
##### 2.2.1.1 QSlim算法  
QSlim是Garland和Heckbert提出的利用二次误差度量（quadric error metric，QEM）来进行迭代边坍缩以实现对三角形网格化简的一种方法，[图2.2]展示了一个简单的边坍缩过程。本小节将首先介绍三角形网格顶点的QEM估计方法，然后介绍经典QSlim算法的过程。  
[图2.2 边坍缩过程]  
- QEM估计  
    在空间中，一个平面$P$可以用如下公式表示：
        $$ n \cdot v + d = 0 $$
    其中$n = (n_x, n_y, n_z)$表示垂直于该平面的单位法向量，即满足$n_x^2 + n_y^2 + n_z^2 = 1$，$v$表示平面上任意一点，$d$表示空间原点到该平面的距离。由此可知平面$P$可由一个四元数表示：
        $$ P = (n, d)^T = (n_x, n_y, n_z, d)^T $$  
    对于空间中任意一个点$v$，其到该平面的带符号距离可以表示为$n \cdot v + d$，计算所得的符号用于确定点$v$处于平面$P$的哪一侧，而通常我们只关注距离的大小，因此定义点$v$到平面的距离平方为：
        $$ D(v) = (n \cdot v + d)^2 $$
    将三维空间点$v$映射到齐次坐标空间得$v = (x, y, z, 1)$，由此点到平面的距离平方可以改写成矩阵形式，即：
        $$ D(v) = (P^Tv)^2 = (P^Tv)^T(P^Tv) = v^T(PP^T)v$$
    定义矩阵$K_P = PP^T $表示平面$P$的基本二次误差，则$K_P$就可以用来计算空间中任何一个点到平面$P$的距离平方。而在三角形网格中，其中一个网格顶点$v$的二次误差度量（QEM）就可以用该点到其周围所有平面的距离平方和来估计，即：
        $$ Q(v) = v^T (\sum_{P \in plane(v)} K_P) v $$
    定义矩阵
        $$Q_v = \sum_{P \in plane(v)} K_P \space \space (*)$$
    表示三角形网格顶点$v$的二次误差度量矩阵，在迭代边坍缩算法执行过程中，如果两个顶点$v_1$和$v_2$将要合并，那么合并后产生的新顶点$\bar{v}$的二次误差度量矩阵就是:
        $$ Q_{\bar{v}} = Q_{v_1} + Q_{v_2} \space \space (**)$$
    这里没有对新顶点$\bar{v}$按照公式(*)重新计算它的二次误差度量矩阵，而是简单的将原来两个顶点的二次误差度量矩阵相加，主要是为了减少计算代价，而由原论文的实验部分可以知道，使用公式(**)也可以保证最终简化网格的视觉质量。  
    [可选  介绍合并后新顶点的位置如何计算]  
- QSlim算法过程  
    QSlim算法正是建立在上述的顶点QEM估计算法的基础之上的，该算法会迭代地坍缩度量误差最小的一条边以最大限度地保留网格原有的形状，该算法可以被描述如下：  
    （1）计算网格所有顶点的二次误差度量矩阵$Q$，  
    （2）计算网格所有边的坍缩代价，方法为对于该边的两个顶点$v_1$和$v_2$，首先决定该边坍缩后产生的目标顶点$ \bar{v} $，然后目标顶点的二次误差度量$ \bar{v}^T (Q_1 + Q_2) \bar{v} $就作为该边的坍缩代价，  
    （3）根据网格每一条边的坍缩代价将其放置到一个最小堆数据结构中，  
    （4）移除上述最小堆的根节点指向的边$(v1, v2)$，  
    （5）计算被移除的边坍缩后应当产生的新的目标顶点，  
    （6）将$v1$和$v_2$坍缩到上述目标顶点上，并更新小根堆中$v_1$和$v_2$的所有邻接边的坍缩代价，  
    （7）迭代执行上述步骤（4）到步骤（6），直到网格达到指定简化程度，即网格顶点数简化到指定顶点数。  
    通常一个网格的分辨率可以由其顶点数量来决定，即顶点数量越多，网格细节越完善，其分辨越高，反之亦然。而QSlim算法每次迭代都会减少一个网格顶点，因此使用QSlim算法可以得到任何分辨率下的三角形网格，即实现了本文所述的网格连续LoD，在渲染时，只需决定该网格的最终需要保留的顶点数量即可。但是QSlim算法存在两个关键问题，第一个问题是是计算较缓慢，因为每次迭代只能坍缩一条边，而且后续的边坍缩依赖于先前的结果，所以很难做并行化处理；第二个问题是存储开销高，因为网格的每一条边都需要计算坍缩代价，而且算法执行过程中需要一直维护一个堆结构。
##### 2.2.1.2 GPU可并行的网格简化  
QSlim算法在提出后的十几年里不断得到发展和改进，随着硬件技术的进步，越来越多的研究着手于在GPU中实现网格简化算法。其中Peng和Cao提出了一种可在GPU中并行计算的网格简化算法，他们的算法也是基于边坍缩算法的思想，同时Peng和Cao还提出一种了可充分利用GPU内存资源的连续LoD选择方法。本小节将介绍这种可在GPU中并行计算的网格简化算法，而连续LoD选择方法将在下一小节介绍。
GPU可并行的网格简化算法将分为GPU友好的预处理和三角形网格重建两部分分别介绍。
- GPU友好的预处理   
    GPU友好的预处理过程与经典的QSlim算法过程基本一致，主要工作是在边坍缩算法执行过程中，将一些中间结果存储在的数组结构中，以便在需要时，根据这些中间结果快速的重构出不同分辨率下的三角形网格，这些存储中间结果的数据结构包括：$ECol$，用于存储每个迭代过程的边坍缩操作；$PermuteT$，存储边坍缩操作之后每个三角形的新编号；$PermuteV$，存储边坍缩操作之后每个顶点的新编号；$Map$，存储了边坍缩操作之后不同分辨率网格的顶点个数及三角形个数的映射关系。与QSlim算法有三点不同，其一是原论文的方法中处理一条边的坍缩时不会出现新的目标顶点，而是这条边的其中一个顶点会坍缩到另一个顶点，这样做的好处是保证简化后的网格顶点集合是原来网格顶点集合的子集，便于后续在GPU中并行重构三角形网格。为了保持网格的最小视觉质量，原论文严格限制边界边参与边坍缩操作，并规定了边界顶点的坍缩方法，如果用$Q$表示所有边界顶点的集合，那么由$v_a$和$v_b$组成的边坍缩方程表示如下：
        $$Collapse(v_a, v_b) = \begin{cases}  
        v_a \rightarrow v_b, & (v_a \notin Q) \\
        v_b \rightarrow v_a, & (v_a \in Q, v_b \notin Q)  \\
        N/A, & (v_a,v_b \in Q)  \\
        \end{cases} , \space \space where \space a < b
        （公式1）$$
    其中$\rightarrow$表示边坍缩方向，即$v_a \rightarrow v_b$表示源顶点$v_a$将坍缩到目标顶点$v_b$，而$N/A$表示不做任何坍缩处理。注意到边坍缩方程中规定了顶点编号的大小关系，即 $ a<b $，这么做的目的是方便后续为每个进行坍缩操作的顶点重新编号。  
    其二是原论文中计算每条边的坍缩代价并没有采用QEM估计方法，而是根据每条边的长度以及该边对应的两个顶点的局部曲率特征来定义这条边的坍缩权重，其计算公式如下：
        $$cost(u, v) = \|u-v\|*\max_{f \in Tu}\{ \min_{n \in Tuv} \{ (1- f.normal \cdot n.normal)/2 \} \}（公式2）$$
    其中，$u$和$v$表示该边的两个顶点，$Tu$表示所有包含顶点$u$的三角形集合，$Tuv$表示所有包含顶点$u$和顶点$v$的三角形集合。需要说明的是，$\|u-v\|$表示该边的长度，其长度越小，坍缩的代价就越低，而$(1- f.normal \cdot n.normal)/2$可以用来表示三角形$f$和三角形$n$的二面角大小，在三角形网格的研究中，经常会用二面角来衡量某个顶点的局部曲率特征。  
    其三是原论文会在每次边坍缩操作之后，对得到的新版本网格的顶点和三角形进行重新编号，编号的顺序对应者边坍缩操作的迭代顺序，这样做的目的是帮助后续重构三角形网格算法可以快速定位到简化网格所需的原三角形网格编号，以便推进三角形网格的重构顺利。  
    [图2.3 三角形网格简化算法预处理示例]  
    [图2.3]展示了GPU友好的预处理过程及其产生的中间结果，可以将该过程总结为以下5个步骤：  
    （1）选择一条待坍缩的边。所有边的坍缩代价都会由（公式2）计算得出，而边界边的坍缩代价会设置为一个较大的值，在每次迭代过程中，选择坍缩代价最小的边，利用（公式1）进行边坍缩操作。假设坍缩的源顶点为$v_{src}$，坍缩的目标顶点为$v_{tar}$，那么该坍缩操作会被记录在$ECol$中，表示为$ECol(src) = tar$。  
    （2）顶点置换。假设$m$表示在进行边坍缩操作之前网格的顶点数量，而这次边坍缩操作的源顶点是$v_{src}$，那么源顶点的编号将会被置换为$m$并记录在$PermuteV$中，表示为 $ PermuteV(src) = m $。    
    （3）顶点和三角形的数量映射。在进行边坍缩操作之后，假设$m$表示网格顶点数量，$n$表示网格的三角形数量，那么这一对关系会被记录在$Map$中，表示为$Map(m)= n$。  
    （4）三角形置换。假设$n$表示边坍缩之前网格的三角形数量，$t_{r1}$和$t_{r2}$分别表示边坍缩后被移除的三角形，其中$r1 < r2$，类似于步骤（2），原网格的三角形编号也会背置换，置换结果会保留在$PermuteT$中，分别表示为$PermuteT(r1) = n$以及$PermuteT(r2) = n - 1$。  
    （5）迭代地进行上述步骤（1）到步骤（4）。  
    注意到原论文对于边界边是不执行边坍缩操作的，因此上述的4种数据结构需要用省缺值补充完整，其中$ECol$和$Map$省缺部分用$-1$填充，表示对应的操作或映射没有意义，而$PermuteV$和$PermuteT$省缺的部分按从左至右，从大至小的编号填充，最后填充的省缺值都是$1$，其过程如[图2.3 (e)]所示。  
    利用上述所得的4种数据结构就可以对原三角形网格进行重排列，重排列的结果有助于根据后续具体选择出的网格顶点数量来确定网格的形状。具体来说，定义原网格为$M = (V, T)$，其中$V=\{v_1, v_2, ... , v_m\}$表示网格所有顶点集合，$T = \{ t_1, t_2, ..., t_n \}$表示原网格所有三角形集合，重排列后的网格定义为$M' = (V', T')$，其中$V' = \{ v_{m_1}, v_{m_2}, ..., v_{m_m} \}$表示重排列后网格的顶点集合，$T'=\{ t_{n_1}, t_{n_2}, ..., t_{n_n} \}$表示重排列后网格的三角形集合，注意两个网格的拓扑结构是完全一致的，只是顶点和三角形的编号有所不同。而在重构三角形时，假定当前选择的网格顶点数量是$i$，其对应的三角形数量就是$j = Map(j)$，此时重构的简化网格的顶点集合就是$V_{LoD_i} = \{v_{m_1}, v_{m_2}, ..., v_{m_i}\}$，而重构网格的三角形集合就是$T_{LoD_j} = \{t_{n_1}, t_{n_2}, ..., t_{n_j}\}$。三角形网格的重排列算法如下所示，[图2.4]展示了重排列后网格顶点编号、三角形编号以及$ECol$数组的变化，根据重排列后的$ECol'$数据就可以快速将$V_{LoD_i}$集合中的顶点编号快速置换回原始网格对应的顶点编号。
    [图2.4 三角形网格重排列示例]
    ```
    Algorithm 1: Data Rearrangment  
    Input: V, T, ECol, PermuteV, PermuteT  
    Output: V', T', ECol'  
    1. for each vi in V do:
    2.   ECol'[permutetV(i)] <- permuteV[ecol(i)]
    3.   V'.vpermutteV(i) <- V.vi;
    4. end for  
    5. for each ti in T do  
    6. T'.tpermutetT(i) <- T.ti;
    7. end for  
    ```
- 三角形网格重建  
    三角形重构发生在运行时，可以利用GPU的高并发性以及前期的预处理工作快速重构出简化版本的三角形网格。上一小节提到，在三角形网格重构之前，需要经过LoD选择确定简化网格的顶点个数，然后由$Map$数据结构获取简化网格的三角形个数，由此就可以知道简化网格在重排列后的原始网格中所需的所有的顶点编号和三角形编号，最后根据重排列后的$ECol'$数组就可以在原始网格中重构出指定LoD的简化网格，其过程如[图2.5]所示。三角形网格的重构算法如下，其中T表示上文选择出的$T_{LoD_j}$三角形集合，$n$表示选择出的顶点数量。注意到在算法中，由LoD选择出的三角形集合中的每一个三角形都可以并行地寻找其在原始网格中的顶点编号。
    ```
    Input: T, n, ECol'
    Output: T'  
    1. for each tk in T paralled do
    2.   for i = 1 to 3 do  
    3.     vidx <- the ith vertex index of tk;
    4.     while vidx > n do
    5.       vdix <- ecol(vidx);
    6.     end while
    7.     replace ith vertex index with vidx;
    8.   end for
    9. end for
    ```
    [图2.5 三角形平行重构过程]
##### 2.2.1.3 连续LoD选择  
通过上一小节介绍可以知道如何利用边坍缩的思想在GPU上并行地计算简化版本的三角形网格，至此只剩最后一个需要解决的问题，即如何在确定网格简化程度。网格的简化程度一般就指网格的顶点数量和三角形数量大小，而三角形数量和顶点数量相对应，因此确定网格的简化程度往往就是确定网格顶点数量，本小节就将介绍一种LoD选择方法来确定网格的顶点数量，并以此重构LoD选择出的网格。在常识上，一个物体离摄像机越远，那么该物体被捕捉到的细节就会越少，而LoD选择正是基于此来预测网格的细节程度，忽略那些难以被捕捉的细节，从而加快网格的渲染速度。对于一个特定大小的网格而言，其最终在屏幕上的光栅化面积大小可以很好地衡量网格最合适的细节程度。现给定一批待渲染的网格，以下给出了计算每个网格顶点数量的公式：
    $$vc_i = N \frac{w_i^{1/\alpha}}{\sum_{i = 1}^{m}w_i^{1/\alpha}}, \space where \space w_i = \beta \frac{A_i}{D_i}P_i^{\beta},\beta = \alpha - 1$$
公式中，$N$表示在GPU中的顶点内存预算，其大小可交由用户配置，$m$表示这批网格的总个数，$vc_i$表示第$i$个网格要被渲染的顶点数量，$A_i$表示网格投影到屏幕空间的面积大小，$D_i$是网格与摄像机视口的距离，$P_i$是网格的原始几何图元数量（对三角形网格而言就是原始网格的三角形数量），最后$\alpha$和$\beta$是用于估计物体可被感知程度的敏感因子，其大小可由用户通过实验得出最合适的值。  
前文提到，网格的边界边是严格禁止坍缩的，因此最终计算得出的网格顶点数量不会是一个过小的值，而应该是一个合理区间范围内的值，即$vc_i \in [min_i, max_i]$，$min_i$就是该网格所有边界点的数量，即上文提到的$Q$集合的大小，$max_i$就是该网格原始的顶点数量。由此，通过公式计算的得到的$vc_i$需要再次估计，公式如下：
   $$\bar{vc_i} = \begin{cases}  
   vc_i  & (vc_i \in [min_i, max_i]) \\
   max_i & (vc_i > max_i) \\
   min_i & (vc_i / min_i \in [MinT, 1])\\
   0     & (vc_i/min_i < MinT)
   \end{cases}$$ 
公式会将$vc_i$映射到区间$[min_i, max_i]$，保证了LoD选择结果的合理性。公式中还引入了一个新的参数$MinT$，这个参数是控制网格是否简化到可以忽略其渲染的阈值，即如果经过LoD选择所得的$vc_i$是一个足够小的值，那么其对应网格的渲染可以忽略，否则，尽管计算得到的$vc_i < min_i$，也应该以最简单的简化版本（即$vc_i = min_i）来渲染这个网格。至此，在运行时，根据以上公式计算得出每个待渲染网格的顶点数量，然后根据上一小节的方法重构最终的简化网格，这样就可以渲染出大批量的模型网格，而且模型网格的简化程度也会根据其被渲染的顶点数量而连续变化，即实现了模型网格的连续LoD渲染。  

#### 2.2.2 动画实例化渲染  
- Animation Instancing  
在上一节，本文介绍了如何在GPU并发实现网格简化技术，以实现基于连续LoD的大规模人群动画的实时渲染。本节将介绍另一种用于实现实时大规模人群渲染的技术，即动画实例化渲染技术，该技术不是直接加快了渲染管线的执行速度，而是提高了CPU与GPU之间的通信效率，以此来提高群体动画的性能。不同于传统的骨骼动画需要每帧进行独立的骨骼计算从而造成大量计算资源消耗，动画实例化技术通过引入实例化的概念，在渲染时将相同动画的物体合并为一个实例化群体，共享相同的骨骼动画数据，其所有计算消耗，包括骨骼计算和蒙皮计算，都是在GPU中完成的。接下来本文将介绍动画实例化技术的实现细节。  
根据动画蒙皮公式可知，一个角色动画的实现依赖绑定姿势、动画姿势、蒙皮权重以及蒙皮网格，动画实例化技术正是将角色所有动画姿势打包成2D动画纹理，在运行时，根据CPU中传入的角色实例数据以及角色的动画纹理，就可以在GPU中处理角色动画姿势并为角色动画蒙皮。在介绍骨骼动画基础知识时，本文提到一个角色动画其实是该角色一系列姿势的集合，而角色姿势由其所有骨骼的位置、旋转和缩放等空间变换来决定，一般可以用一个$4 \times 3$矩阵来表示一个骨骼的空间变换。一张2D纹理图的每一个文素可以存储一个RGBA值，鉴于动画姿势中每个骨骼的空间变换都是相对于其父骨骼而言的，其值相对较小，因此每个纹素可以存储4个浮点数，即RGBA值的每个通道各存一个浮点数，所以一个骨骼的空间变换可以用3个纹素来存储。用这种格式存储角色动画，那么可以将纹理的每一行存储为角色的一个姿势，这一行就可以表示动画的一个关键帧，而整个动画就可以用连续的行来表示，最终，角色的所有动画被烘培成若干张2D纹理图。在运行时，根据当前时间和角色动画索引就可以从动画纹理中为该角色采样姿势。而蒙皮权重和绑定姿势信息对于同一类型的角色来说是静态的，可以将这些资源提前加载到GPU的内存中，最终角色将利用这些信息为动画正确地蒙皮。
- 动画实例化技术的限制  
虽然动画实例化技术在提高动画渲染性能和效率方面有很多优势，但也存在一些限制和考虑因素，比如动画实例化技术仅对单一的动画片段采样而无法像传统的动画状态机一样可以对动画进行细微和复杂的控制，比如动画实例化技术很难做到二维甚至更高维的动画融合，比如动画实例化技术很难支持部分姿势融合（如人形角色仅上半身的动画融合），等等。
### 2.4 本章小结  
## 第3章 动画状态共享模型  
### 3.1 引言
- 结合实际需求解释为何希望动画在CPU中运行  
    在第一章，本文提到了群体中每个个体角色的骨骼动画可以在CPU或GPU中得到实现，并分别阐述了两种实现方案的优劣，即在CPU中实现的骨骼动画能够保留动画的灵活性和复杂性，可以对动画进行更加精细的控制，如应用RootMotion技术可以精准地控制角色在动画过程中的移动逻辑，应用动画IK（Inverse Kinematics）技术可以更加真实地表现角色在凹凸不平的地面行走的状态，但CPU受限于性能，在处理海量动画骨骼计算时可能造成系统性能过载而使帧率降低。相反，GPU处理骨骼动画占据了性能优势，可以快速计算出大量骨骼位置，而为此付出的代价就是减弱了动画的表现力。考虑到本文的研究内容最终会应用到实际的游戏项目中，而游戏对于动画群体的需求较为复杂，例如击中游戏中的怪物时需要根据击中部位运行相对应的伤害或表现逻辑等等，这些需求的存在要求在CPU端保留每个怪物角色的骨架姿势以方便与游戏其他模块（如伤害计算模块）进行交互。因此，本文选择将群体中个体的动画实现放在CPU端进行。  
- 说明在CPU中运行动画会存在哪些问题  
    但正如前文所说，在CPU处理海量角色的骨骼动画存在可能的性能过载问题，当群体规模达到一定程度时，会造成帧率骤减，无法满足实时性的要求，影响用户体验。尽管当今许多游戏引擎引入了各种动画性能优化技术，但只能小幅度提升动画群体体量，难以满足日趋膨胀的需求。  
- 引出动画状态共享的概念  
    考虑到虽然动画群体的规模会无限扩大，但群体中每个角色使用到的动画资源是相对有限的，因此对于一个大规模的群体而言，可能有相当部分的个体动画状态是接近甚至相同的，如果能够合并这些动画的计算，那将会给CPU的动画处理节约大量性能。基于此，本文提出了一种动画状态共享模型，该模型需要先定义出若干种不同的动画状态及其动画表现，在运行时，每个角色只需要根据上下文条件选择正确的动画状态，并直接复用该状态已经处理好的动画姿势即可，而不需要再单独进行动画片段采样、动画姿势计算等动画处理工作了。为了避免因许多角色因共享同一个动画状态以至于出现明显的动作重复现象，本文将引入一个偏差值变量来差异化同一动画状态下不同个体的动画表现。  
### 3.2 动画状态共享模型框架  
- 给出动画状态共享模型的总体架构并说明其意义  
    本文提出的动画状态共享模型总体架构如[图3.1]所示，架构中包含的元素有动画角色、动画共享状态处理器、动画共享实例、动画共享管理器、动画状态实例桶、动画过渡实例桶。该动画共享模型允许多个动画角色共享同一个动画状态实例，以减少计算每个角色动画姿势的开销，该模型还考虑了不同动画状态之间的过渡转换问题并支持动画叠加机制。下文将会阐述动画状态共享模型架构中每个元素的意义和作用。
    [图3.1 动画状态共享模型的总体架构]  
- 说明架构每个部分的含义   
    （1）动画角色：这里特指注册到该动画状态共享系统中的角色，此时这些角色的动画将会由该动画状态共享系统接管，但是他们的动画状态可以根据设计需要由外部系统（例如角色的决策系统）或内部系统（即该动画状态共享系统）来决定。
    （2）动画共享状态处理器：主要作用是决定每个角色最终的动画状态并决定是否需要处理该状态，其具体的执行逻辑可交由用户配置。
    （3）动画共享实例：动画状态共享系统的核心组件，它负责驱动更新注册进系统的每个角色的动画状态、动画过渡状态、动画叠加状态等等。从图1可知，系统中会存在若干个这样的动画共享实例，每个实例对应不同骨架类型的动画角色，这意味着系统可以支持多种不同类型角色的动画共享。
    （4）动画共享管理器：拥有并管理若干个动画共享实例，同时也是唯一对外提供接口的系统组件，用户将在运行时通过操作这些接口来真正运行动画状态共享系统。
    （5）动画状态实例桶：每一个动画状态实力桶都存储了若干个该种状态下的动画片段实例以供动画角色直接复用，需要指出的是，某一个动画状态可能拥有若干个不同的动画片段实例，这是为了丰富同一个状态下的动画表现。
    （6）动画过渡实例桶：不同动画状态之间的转换需要通过动画过渡来平滑流畅地衔接转换过程，而这个过程将会由动画过渡实例来完成，用户需要预先配置最大的动画过渡实例个数，而动画状态共享系统会根据运行时条件为需要进行过渡的动画角色选择最合适的动画过渡实例。
- 再次说明动画状态共享模型的作用和意义  
    动画状态共享模型为大规模角色人群提供了一种动画实现方案，这种方案下，人群中每一个角色的动画都会直接复用其对应状态下的动画实例，所以群体中每个个体因动画处理消耗的性能总和不会超过该框架运行时动画性能总和，相当于框架定义了一个最大的动画性能消耗预算，无论动画群体规模有多庞大，其总的动画性能消耗都不会超过这个预算。
### 3.3 动画状态共享模型设计与实现  
- 说明动画状态共享模型的工作流，包括编辑阶段和运行时  
    本小节将通过动画状态共享模型的工作流程来阐述该模型的设计与实现方案，其工作流程如[图3.2]所示。整个工作流程可以总结为编辑阶段和运行时阶段，编辑阶段需要用户为动画状态共享系统提供必要的配置，包括动画状态定义、动画状态处理、动画共享设置。在运行时阶段，系统会首先根据编辑阶段的配置信息初始化整个动画共享系统，然后更新所有被注册进系统的动画角色的动画状态和表现，最后在动画共享系统销毁之前，需要将这些动画角色注销，将他们的动画控制权返还给原来的系统。下文会详细阐述每个工作的阶段的实现细节及数据流向。  
    [图3.2 动画共享模型工作流]
- 说明工作流中各个阶段的任务、作用和数据流  
    - 编辑阶段：定义动画共享状态枚举、配置动画共享状态处理器、配置动画共享设置  
    （1）定义动画状态  
        应用动画共享模型的第一步就是定义角色可能存在的所有动画状态，在本文实现的动画状态共享模型框架中，针对于某种特定类型的角色，其动画状态被定义为：
            $$AnimState = (StateID, AnimationClips, Pose，IsAdditive, SkeletalMask, InstanceCount)$$
        $StateID$是每个动画状态的唯一标识，用于区分和识别每个不同的动画状态。$AnimationClips$是用于表现该状态的动画片段数组，用户可以根据需要配置若干个不同的动画片段，在运行时，动画状态共享系统会为该状态下的角色随机选择其中一个动画片段播放。
        $IsAdditive$用来标记这个动画状态是否可叠加，如果该状态是可叠加的，那么处于该状态的角色会将当前状态下动画姿势于前一个状态的动画姿势进行叠加融合以丰富动画表现的多样性，如果该状态是不可叠加的，那么这个状态下的角色只会表现该状态规定的动画。$SkeletalMask$是角色骨架的掩码，它标记了该状态下的角色在处理动画骨骼时，哪些骨骼需要参与计算，哪些骨骼可以不参与计算，在表示上骨架掩码可以是一个0-1序列。 即:
            $$SkeletalMask = \{mask(i) \space | \space mask(i)取值为0表示第i个骨骼会参与姿势计算，取值为1则不会\}$$  
        如果该状态下角色的每一个骨骼都需要参与动画姿势计算，那么这个状态的$SkeletalMask$就可以表示为：
            $$SkeletalMask_{full} = \{ mask(i) = 1 \}$$
        最后$InstanceCount$指每个动画状态最多拥有的实例个数，上一节说到了一个动画状态实例可以直接供该状态下需要使用该实例动画的角色复用，每一个动画实例虽然都代表这同一个动画状态，但其动画表现略有不同，因为在动画状态共享系统初始化时，每一个动画状态实例都会有一个偏差值，这个偏差值的存在会使同一个动画片段从不同的时刻开始播放，这样做的好处就是进一步丰富了大规模群体中角色动画的多样表现。  
    （2）定义动画共享状态处理器  
        在定义好角色的动画状态之后，就需要动画状态处理器来决定动画共享系统中的角色当前应该处于那种状态，它可以基于预先定义的状态转化条件和优先级来进行决策，从而有效避免不符合用户预期的状态转换。例如，如果角色当前处于“行走”状态，动画状态处理器将检查是否有任何条件触发了状态的转换，如角色是否发起了“攻击”指令。如果有条件满足，动画状态处理器将根据用户定义的动画状态转换关系决定是否切换到另一个状态。本文将动画共享状态处理定义为一个转换函数：
            $$AnimStateProcessor = DeterminAnimState(FromAnimState, Parameters, ToAnimState, ShouldProcess)$$  
        $FromAnimState$表示角色的当前动画状态，$Parameters$是用户定义的一系列角色状态参数集合，在运行时需要向系统传输对应的参数，$ToAnimState$是根据传入该函数的角色当前状态及其状态参数决定的角色的下一个动画状态，该状态有可能与角色当前状态是一致的，$ShouldProcess$用于决定新的动画状态是否生效，这个字段的存在是为了给利用动画共享系统设计大规模群体动画应用的用户提供更多控制权和灵活性，例如，对于群体中远离摄像机的角色个体而言，它们的动画表现对整个群体的动画表现影响相对较弱，因此其动画状态不需要频繁地更新。
    （3）配置动画共享设置  
        前文中有提到，本文的系统可以支持多种不同骨架的角色，因此这一步骤的动画共享设置就包含了多种不同骨架结构的角色在动画状态共享系统中的初始化设置，而其中一个动画共享设置可以定义为：
            $$AnimSharingSetup = (Skeleton, SkinnedMesh, AnimState, AnimStateProcessor, MaxTransitionCount, TransitionTime)$$  
        $Skeleton$和$SkinnedMesh$分别指角色的骨架及其对应的蒙皮资产，$AnimState$和$AnimStateProcessor$分别为前文中定义好的动画状态和动画共享状态处理器。$TransitionTime$为动画状态过渡需要的时间，$MaxTransitionCount$是指当前允许的最大动画状态过渡实例数量，动画状态之间的过渡表现是用动画过渡实例来完成的，为了得到较好的动画表现，动画状态共享系统需要支持动画状态之间的过渡，如果有同一时间有大量角色处于动画状态过渡过程中，那么动画过渡的计算开销也会非常大，对系统的性能带来巨大压力，因此，在本文的设计中过渡中的角色也应该是被共享的，同一时间的需要计算的动画过渡数量也应该受到限制。关于动画状态之间如何实现的将在后文的运行时阶段介绍，这里需要指出的是，由于本文设定动画过渡也是可以被共享的，因此很可能出现某个角色在所有可以共享的动画状态过渡实例中找不到需要的过渡实例，这是就需要扩大$MaxTransitionCount$以减少这种情况出现的概率，而扩大$MaxTransitionCount$势必会增加系统性能开销，因此需要用户根据需求及群体动画的测试表现结果来选择最优的动画状态过渡实例数量。
    - 运行时：创建动画共享管理器，注册动画角色，更新角色动画，注销动画角色，销毁动画共享管理器。  
    （4）创建动画共享管理器  
        在运行时阶段，首先需要创建动画共享管理器，并用编辑阶段的获得的配置信息初始化它。在本文提出的动画状态共享系统架构中，一个动画共享管理器包含了多个动画共享实例，每个动画共享实例都会某种骨架结构的角色动画更新，其数据结构如[图3.3]所示。  
        [图3.3 动画共享管理器数据结构]  
        从图中可以看出，每个动画共享实例与$AnimSharingSetup$是一一对应的，骨架、动画蒙皮、动画状态处理器分别对应定义的$Skeleton$、$SkinnedMesh$和$AnimStateProcessor$，接下来有一组不可叠加的动画状态实例，每个动画状态实例的定义如下：
            $$ AnimStateInstance = (AnimState, ClipIndex, Offset, SamplingPose, OutputPose) $$   
        其中$AnimState$完全由上一节提到的动画状态配置信息初始化，其实例的数量由$InstanceCount$决定。上一节说到$AnimState$中配置了多个不同的用于表现该动画状态的动画片段，而$ClipIndex$的作用就在于指明具体使用哪一个动画片段，而$Offset$的作用是为共享同一个动画片段的角色做动画差异化，它表示在$ClipIndex$指向的动画片段上做采样的开始时刻。在前文提到，一个动画片段是一系列姿势的集合，为某个角色播放这个动画片段时，其实际就是不断地从该动画片段的姿势集合中采样出一个合适的姿势，并将其应用到角色的骨架中。对于可叠加的动画状态，本文会将其与前一个状态产生的动画姿势进行叠加，因此可叠加的动画状态实例相对不可叠加的动画状态实例，会多一个指向前一个动画状态实例的指针$PreStateInstance$，其定义为：
            $$ AdditiveAnimStateInstance = (AnimState, ClipIndex, Offset, SamplingPose, OutputPose, PreStateInstance) $$  
        在初始化完所有动画状态实例之后，系统需要初始化动画过渡实例，其定义如下：
            $$AnimTransitionInstance = (TransitionTime, FromAnimStateInstance, ToAnimStateInstance, TransitionPose)$$  
        其中$TransitionTime$根据用户的配置决定，$FromAnimStateInstance$和$ToAnimStateInstance$分别表示参与过渡的源动画状态实例和目标动画状态实例，会根据运行时的上下文条件动态指定，即如果角色需要进行动画过渡，它首先查找满足其从源动画状态实例过渡到目标动画状态实例的动画过渡实例，如果查找失败，则系统会选取一个未被使用的过渡实例，并将其源动画实例指定为角色当前动画状态实例，目标状态实例指定为角色需要过渡到的动画状态实例，然后计算该角色过渡姿势，具体过程在更新角色动画阶段会详细阐述。  
            
    （5）注册动画角色  
        在完成动画共享管理器的创建和初始化工作之后，就可以将需要进行动画共享的角色注册到动画状态共享系统中。一个动画状态共享实例除了持有上一小节所述的数据外，还维护了一个动画角色列表，如[图3.4]所示。当注册一个动画角色，首先需要根据该角色的骨架结构选择正确的动画状态实例，然后取消原动画系统对该角色的动画控制权，最后将该角色加入到选出的动画状态实例维护的动画角色列表中即可。在成功注册之后，该角色的动画状态就由之前定义的动画共享状态处理器决定，而动画状态实例会根据角色的具体动画状态为它分配一个动画状态实例或动画过渡实例，角色的最终动画姿势就由其分配得到的实例姿势来决定。在[图3.4]中，每个注册进系统的动画角色都会维护一份角色实例数据，在本文的设计中，角色实例数据定义为：
            $$CharacterInstance = (CurrentStateID, PreviousStateID, InTransition, PermutationIndex, TransitionIndex)$$  
        其中，$CurrentStateID$和$PreviousStateID$分别表示该角色当前动画状态和上一帧的动画状态，$InTransition$表示该角色当前是否处于动画过渡状态，$PermutationIndex$指向该角色被分配到的动画实例（可能是可叠加的动画状态实例也可能是不可叠加的动画状态实例），角色姿势由$OutputPose$决定，$TransitionIndex$指向该角色被分配到的动画过渡实例，其姿势由$TransitionPose$决定。这里需要特别说明的时，角色的动画过渡状态可能被中断，例如角色被攻击命中时需要立即播放一段击中反馈动画，一旦发生这种情况，角色就会进入新的动画过渡状态，即从当前状态向中断状态的过渡。
        [图3.4 动画角色实例数据]  

    （6）更新角色动画  
        一个动画共享系统会有若干个不同的动画共享实例来驱动更新对应骨架结构的角色动画，而更新动画的核心逻辑就在更新角色动画阶段，它直接决定了角色最终的动画姿势。对于一个动画共享实例来说，其更新角色动画阶段可以分4个子阶段顺序执行，分别是更新角色状态、更新过渡实例、更新动画实例、以及应用角色动画，如[图3.5]所示。       
        [图3.5 更新角色动画流程]  

    - 更新角色状态  
        首先是更新角色状态，这一阶段会遍历所有注册进系统的角色，并将它们的上一个动画状态及其对应的状态参数传给前文所述的动画共享状态处理器，获取并更新每个角色当前的动画状态，然后判断角色最新的动画状态与上一次动画状态是否一致，如果两个状态一致，则无需处理。如果两个状态不一致，那么该动画共享实例就会首先为该角色分配其新状态下的动画状态实例，这里需要注意，对于可叠加状态而言，动画共享实例可能找不到一个与该角色前一个动画状态一致的可叠加动画状态实例，即为角色分配动画状态实例失败，此时动画共享实例会放弃此次动画状态的更新，因此对于有重要表现作用的叠加动画来说，需要适当提高其叠加动画实例的数量。如果角色可以成功分配到新状态的动画实例，那么动画共享实例会为该角色分配一个用于表现动画过渡的动画过渡实例，类似于可叠加动画实例的分配，分配动画过渡实例也有可能失败，此时会跳过动画过渡表现，直接让角色进入新的动画状态。在完成所有角色的动画状态更新后，每个角色的实例数据，即$CharacterInstance$，便维护到了最新状态，而动画共享实例还会产生若干个动画过渡实例$AnimTransitionInstance$和若干个动画状态实例$AnimStateInstance$，在以后的阶段会更新这些实例的输出姿势并将其应用到角色动画上。  
      
    - 更新过渡实例       
        接下来是更新过渡实例，这一阶段会更新动画共享实例中所有需要更新的动画过渡实例，即根据上一阶段的处理得到若干个需要进行实际运算的$AnimTransitionInstance$，设$RealTransitionTime$表示实际过渡时间，再根据公式计算出每个动画过渡实例的过渡姿势：
            $$TransitionPose = FromAnimStateInstance.OutputPose + (ToAnimStateInstance.OutputPose - FromAnimStateInstance.OutputPose) * s, s = RealTransitionTime / TransitionTime \in [0,1]$$  
        如果过渡结束，即实际过渡时间已经超过了设定的过渡时间，那么共享这个动画过渡实例的每一个角色将更新它们的角色实例数据，即标记角色处于非过渡状态，取消分配角色的动画过渡实例，并将该过渡实例重新设置为可用状态。  

    - 更新动画实例  
        接下来是更新动画实例阶段，类似于更新过渡实例阶段，该阶段会为所产生的每个动画状态实例计算其最终输出姿势。对于某一个动画状态实例来说，首先根据实例数据的$ClipIndex$和$Offset$，从配置的若干个动画片段中正确采样出该动画状态实例的姿势，其采样姿势可以定义为：
            $$SamplingPose = \{ B(i) \space | \space B(i)表示角色第i个骨骼相对其骨架空间的变换矩阵 \}$$  
        若该动画状态实例是非可叠加的，即$AnimStateInstance$， 则其输出姿势$OutputPose$表示为：
            $$OutputPose = SkeletalMask * SamplingPose$$  
        若该动画状态实例是可叠加的，即$AdditiveAnimStateInstance$，则其输出姿势$OutputPose$表示为：
            $$ OutputPose = SkeletalMask * SamplingPose + (SkeletalMask_{full} - SkeletalMask)  * PreStateInstance.OutputPose $$  
        
    - 应用动画并结合图例进一步说明角色动画更新阶段  
        最后是应用动画阶段，前面几个阶段产生了3种重要的数据流，一是角色实例数据，一是动画状态实例数据，一是动画过渡实例数据，其中角色实例数据指明了该角色将如何获取到它的动画姿势。具体来说，如果该角色处于动画过渡状态，那么它的动画姿势将由$TransitionIndex$所指向的动画过渡实例的过渡姿势$TransitionPose$决定，如果角色不处于动画过渡状态，那么它的动画姿势将由$PermutationIndex$所指向的动画状态实例的输出姿势$OutputPose$决定。  
        [图3.6]展示了某一时刻动画共享系统以及其中若干角色可能的动画状态，本小节将通过此图来进一步说明动画共享系统在运行时是如何工作的。

    （7）注销动画角色和销毁动画共享管理器  
        在运行时阶段，可以根据具体条件随时注销某个动画角色，注销后，动画状态共享系统就会删除这个角色的实例数据，并将其动画控制权返还给原来的系统。而销毁动画共享管理器意味着整个动画状态共享系统的结束，此时系统会自动注销所有动画角色并删除其持有的所有实例数据。

### 3.4 关于动画状态共享系统的其他讨论  
- 动画状态实例差异化的讨论  
- 无法找到动画过渡实例实例的情况  
- 动画过渡中断的情况（如击中反馈）  
- 动画融合问题与动画叠加问题  
- 根据优先级（如角色与摄像机的距离）设定动画表现精度的问题  
    为角色维护一个优先级数据，在动画实例不够分配的情况的下，根据优先级可以忽略某些动画的精细表现 
- 注销动画角色时如何表现平滑过渡   
- 其他动画特性的讨论，如IK  
- 探索方案在GPU上实现的可能性  
### 3.5 本章小结  
## 第4章 基于连续LoD的动画渲染加速算法  
### 4.1 引言  
- 承接上文  
上一章介绍了本文提出的动画共享模型，不仅可以在CPU端快速计算出大规模群体的动画骨骼姿势，而且支持动画过渡和动画叠加，丰富了群体动画的细节，增强了群体动画表现力，同时CPU端的实现方案也保留了群体动画产生复杂交互的便利性。但是一个完整的骨骼动画表现除了需要计算骨骼姿势之外，还要为动画进行蒙皮操作。因此，随着群体规模的扩大，大量动画蒙皮操作及其渲染逐渐成为系统性能的瓶颈所在。  
- 对于离散LoD说明连续LoD的优点  
当前绝大部分动画渲染架构中，都会将动画蒙皮放在GPU中进行以加快计算效率。而在GPU的实现方案中，LoD技术是最常用的一种渲染优化技术，通过使用LoD，模型网格会被渲染成不同简化程度的版本以减少渲染成本，其中离散LoD是最简单易用的，但是在群体渲染中离散LoD的应用可能会给群体动画的最终渲染效果造成一种“弹出式”的视觉伪像，为了避免这种现象出现，本文选择使用连续LoD技术来加快大规模群体动画蒙皮的计算和渲染工作。  
- 说明连续LoD的缺陷（基于静态网格）并提出本文研究  
然而，正如前文所言，通过连续LoD技术来简化模型网格的研究已经相当成熟，但现存的相关技术并不能完全满足本文研究需求。例如，大多数通过连续LoD来简化模型网格的方案都是基于静态网格的，而本文需要研究如何简化动态网格（如角色动画蒙皮网格）。因此本文改进了基于边坍缩的网格简化算法，提出了一种GPU可并发的动画网格简化算法（Parallel Animation QSlim, PAQSlim），在提高群体动画渲染效率的同时通过为模型选择合适的LoD还能充分利用了GPU内存。  
### 4.2 可并发的动画网格简化算法（PAQSlim算法）  
- 说明第2章并发网格简化算法的不足之处并提出PAQSlim算法  
第二章介绍了一种可在GPU并行的网格简化算法，可以在运行时快速得到由LoD选择出的低分辨率网格，非常适合渲染大批量的网格。但是这种网格简化算法适用于静态网格，而本文研究内容是大规模群体动画的实时渲染，研究对象是动态的蒙皮网格。因此，本文改进了GPU并行的网格简化算法，综合考虑角色骨架变化对动画蒙皮网格的影响，提出了一种可支持GPU并行的动画网格简化算法——PAQSlim算法。本小节将详细介绍PAQSlim算法。
#### 4.2.1 动态二次误差度量方法（DQME算法）    
- 定义问题域  
    应用QSlim算分的关键一步是估计每条边的坍缩代价，考虑到动画蒙皮网格是虽时间变化的，不能直接使用QME，因此本文综合了骨骼对动画蒙皮的影响，提出了一种适用于蒙皮网格的动态二次误差度量方法（Dynamic Quadric Error Metric, DQEM）。在DQEM估计中，一个动画网格被定义为$AnimMesh = (V, T, B)$。其中$V$是动画网格的顶点集合，$T$是动画网格的三角形集合，$B$是该动画对应骨架的所有骨骼集合。顶点集合中的每一个顶点$v \in V$都会受到至多4个骨骼的影响，用一个四元组$MeshWeight=(w_0, w_1, w_2, w_3)$表示，$w_i(i = 0, 1, 2, 3)$是一个32位整数，前16位表示影响该顶点的骨骼在$B$中的索引，后16位表示该顶点的影响权重。骨骼集合中每一个骨骼$b \in B$表示其相对它父骨骼$p_b \in B \bigcup \emptyset$的空间变换，若$p_b = \emptyset$，则骨骼$b$就是骨架空间的根骨骼。不同于一般情况下骨骼$b$用一个$4 \times 3$矩阵表示它的位置、旋转和缩放信息，本文选择用一个四元数表示一个骨骼相对其父骨骼的旋转，即$b = (R_b, pdf_b, p_b)$，$R_b$是一个表示骨骼$b$旋转的四元数 $p_b$指向骨骼$b$的父骨骼，于是所有骨骼的旋转信息组成了骨架的姿势。  
    骨架的姿势并不是静态的，而是随着时间的增长而变换，因此本文将用一个概率密度分布函数来预测某一时刻的姿势状态。定义$pdf_b$来描述骨骼$b$在其父骨骼空间的旋转分布情况，考虑到旋转的直观性，本文没有直接在表示旋转的四元数空间上定义这个概率密度分布函数，而是在旋转对应欧拉角的三维空间上定义骨骼$b$旋转的联合概率分布函数，并合理假设三个维度的旋转相互独立，即有
        $$pdf_b = pdf_b^{roll} pdf_b^{pitch} pdf_b^{yaw}$$
    其中$pdf_b^{roll}$，$pdf_b^{pitch}$，$pdf_b^{yaw}$分别表示骨骼$b$在$roll$，$pitch$，$yaw$三个自由度上的旋转概率密度分布。  
    现假设随机变量$\gamma$，$\alpha$，$\beta$分别表示联合概率分布$pdf_b$在$roll$，$pitch$，$yaw$三个维度上的欧拉旋转，那么骨骼$b$相对于其父骨骼空间的旋转就可以表示为  
    $$R_b = Quaternion(\gamma, \alpha, \beta)$$
    $Quaternion$是一个表示欧拉角转换到四元数的函数。位了后续蒙皮顶点的计算，将骨骼$b$的空间坐标用矩阵表示为：
        $$M_b = (T_b, R_b, S_b)$$
    其中，$T_b$和$S_b$分别表示骨骼$b$相对其父骨骼的位移和缩放，这两个值可以认为是固定的。同样的方法，可以得到骨骼$b$的父骨骼的矩阵$M_{p_b}$。
    对所有骨骼进行旋转采样，就可以确定骨架的一个姿势$P$，再对姿势$P$应用蒙皮，假设$v(P)$表示该蒙皮网格的一个顶点，则有
        $$v(P) = \sum_{i=0}^3w_i(M_{p_b}M_b)M_{bind_b}^{-1}v(P_{bind}),where \sum_{i=0}^3w_i = 1$$
    其中，$w_i$表示骨骼$b$对顶点$v(P)$的影响权重，$M_{bind_b}^{-1}$表示骨骼$b$在绑定姿势空间的矩阵表示，$v_(P_bind)$表示顶点$v$在绑定姿势下蒙皮位置。

- QEM改进（基于姿势概率的积分）  

- DQME实现（蒙特卡洛积分实现）  
- 概率分布函数讨论  
#### 4.2.2 可并发的网格简化算法改进  
- 利用DQME方法估计每个边坍缩代价  
- 取消边界边合并的考虑  
- 连续LoD选择  
- 并发三角形重构  
### 4.3 动画渲染实例化管理  
- 数据流组织和管理     
### 4.5 本章小结  
## 第5章 实时大规模群体动画渲染系统的实验与性能分析  
### 5.1 项目背景
### 5.2 当前项目的动画渲染瓶颈
### 5.3 当前项目动画性能和改进方案后动画性能的对比  
### 5.4 动画性能总结分析  
### 5.5 本章小结
## 第6章 大规模群体动画渲染系统的实现与测试
### 6.1 大规模群体动画渲染系统框架
### 6.2 在CPU端实现动画状态共享  
### 6.3 在Unity中实现动画共享模型  
- 说明unity动画的实现方式以及蒙皮的实现  
- 设计实现主姿势组件系统  
- 动态rigging  
- 以插件的形式在unity中实现动画状态共享模型  
### 6.4 在GPU端实现动画渲染  
### 6.4.1 基于连续LoD的动画渲染框架总览  
本文设计的在GPU上实现的基于LoD的动画渲染框架如[图6.1]所示，分为CPU端的网格简化预处理和GPU端的动画蒙皮渲染管线两部分。在网格简化预处理部分，本文改进了基于边坍缩的网格简化算法，综合考虑了角色骨架对其蒙皮顶点影响，提出了一种独立于角色骨架姿势的蒙皮网格简化方法。在动画蒙皮渲染管线部分，本文会为每一个角色都会选择出最合适的LoD网格，合理地控制需要渲染的顶点数量，最后利用实例化技术为群体中的角色进行蒙皮并渲染出来。  
#### 6.4.2 预处理部分
#### 6.4.3 连续LoD选择  
- 说明LoD选择的含义和作用  
- 给出LoD选择公式  
- 说明该公式的意义  
#### 6.4.4 模型网格重构   
- 结合关键技术综述，给出重构后的网格顶点集合  
- 给出伪代码和必要说明  
##### 6.4.5 动画蒙皮和渲染
### 6.5 本章小结  
## 第7章 总结与展望  
### 7.1 总结  
### 7.2 展望  
## 参考文献
## 作者经历
## 致谢
